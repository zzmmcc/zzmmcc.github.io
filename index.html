<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="ZMC">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">ZMC</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">ZMC</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">ZMC</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-docker笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/28/docker笔记/" class="article-date">
      <time datetime="2019-07-28T09:02:13.000Z" itemprop="datePublished">2019-07-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/28/docker笔记/">docker笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>###mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#启动docker服务</span><br><span class="line">systemctl start docker.service</span><br><span class="line">#搜索</span><br><span class="line">docker search name</span><br><span class="line">#下载</span><br><span class="line">docker pull name</span><br><span class="line">#运行创建一个mysql实例,p 映射端口号，-e设置账号密码,d后台，--name设置名称</span><br><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line"></span><br><span class="line">#查看运行的容器</span><br><span class="line">docker ps</span><br><span class="line">#运行mysql</span><br><span class="line">docker exec -it mysql bash</span><br><span class="line">#进入mysql控制台</span><br><span class="line">mysql -u root -p</span><br><span class="line">#更换docker源</span><br><span class="line">vim /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [</span><br><span class="line">&quot;https://kfwkfulq.mirror.aliyuncs.com&quot;,</span><br><span class="line">&quot;https://2lqq34jg.mirror.aliyuncs.com&quot;,</span><br><span class="line">&quot;https://pee6w651.mirror.aliyuncs.com&quot;,</span><br><span class="line">&quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">&quot;http://hub-mirror.c.163.com&quot;</span><br><span class="line">],</span><br><span class="line">&quot;dns&quot;: [&quot;8.8.8.8&quot;,&quot;8.8.4.4&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/18/SpringBoot笔记/" class="article-date">
      <time datetime="2019-07-18T14:34:41.634Z" itemprop="datePublished">2019-07-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#<strong>SSM笔记</strong></p>
<p>##AOP：<br>    使用注解需要在切面类上添加<br>    @Aspect            声明是一个切面类<br>    @Component<br>    @EnableAspectJAutoProxy            开启自动代理<br>    使用配置文件需要引入org.aspectj.aspectjweaver<br>    <a href="aop:config" target="_blank" rel="noopener">aop:config</a>        父级标签<br>        &lt;aop:aspect id=”” ref=”引入切面类bean的id”&gt;<br>            &lt;aop:before method=”切面类中的某个方法名（只需要方法名，不要括号）”  pointcut=”execution（* <em>..</em>.<em>（..））”/&gt;<br>            &lt;aop:around method=”printEditLog” pointcut=”execution(</em> <em>..</em>ServiceImpl.edit(..))”&gt;<br>            <!-- 
                使用around的时候 需要在增强方法传入一个ProceedingJoinPoint类型的对象，在该对象.proceed();前后各执行一个方法，这是环绕通知
                public void printEditLog(ProceedingJoinPoint pjp){
                    printQuerytLog();
                    try {
                        pjp.proceed();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                    }
                    printEdit();
                }
            --><br>        <br>    </p>
<p>##SpringMVC:<br>    其中关于日期的转换问题：<br>        1.前端传值到方法中进行参数绑定时，会出现日期格式为null，此时需要写一个日期转换类，继承Converter接口<br>                public class DateConverter implements Converter&lt;String, Date&gt; {}<br>            然后在springmvc.xml文件进行注册<br>                <bean class="org.springframework.context.support.ConversionServiceFactoryBean" id="converterDate"><br>                    <property name="converters"><br>                        <set><br>                            <bean class="com.zz.util.DateConverter"></bean><br>                        </set><br>                    </property><br>                </bean><br>            在mvc的注解驱动中绑定<br>                &lt;mvc:annotation-driven conversion-service=”converterDate”/&gt;<br>        2.后端返回json类型的实体数据带有日期格式，前端接受的为此时间到1970-01-01的毫秒数，需要在实体类继承JsonSerializer<date><br>            重写方法public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {<br>                        SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd : hh:mm:ss”);<br>                        String s = sdf.format(date);<br>                        jsonGenerator.writeString(s);<br>                    }<br>            在日期类型的get方法上@JsonSerialize(using = 实体类.class)<br>    springMVC实现文件上传：<br>        首先需要在springmvc.xml文件配置<br>            <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>                <property name="maxUploadSize" value="104857600"></property><br>            </bean><br>        然后在tomcat服务器的配置文件中配置（tomcat X.X/conf/web.xml的servlet标签中）<br>            <init-param><br>                <param-name>readonly</param-name><br>                <param-value>false</param-value><br>            </init-param><br>        1.同服务器上传：<br>            public String uploadTest(HttpServletRequest request, MultipartFile upload) throws IOException {<br>                String path = request.getSession().getServletContext().getRealPath(“/upload”).toString();<br>                File file = new File(path);<br>                if (!file.exists()){<br>                    file.mkdirs();<br>                }<br>                String filename = upload.getOriginalFilename();<br>                filename = UUID.randomUUID().toString()+”-“+filename;<br>                upload.transferTo(new File(file,filename));<br>                return “index”;<br>            }<br>        2.跨服务器上传：<br>            public String uploadOther(MultipartFile upload) throws IOException {<br>                String path = “<a href="http://localhost:8081/upload/&quot;" target="_blank" rel="noopener">http://localhost:8081/upload/&quot;</a>;<br>                File file = new File(“/upload”);<br>                if (!file.exists()){<br>                    file.mkdirs();<br>                }<br>                String filename = upload.getOriginalFilename();<br>                Client client = Client.create();<br>                WebResource resource = client.resource(path + filename);<br>                resource.put(upload.getBytes());<br>                return “index”;<br>            }</date></p>
<p>##SSM整合：<br>    引入jar包<br>        Spring(context,aop,tx,aspectjweaver,web,webmvc,jdbc,test)<br>        MyBatis(mybatis,mybatis-spring)<br>        其他(junit,mysql,druid,jackson-core/databind/annotations,log4j,slf4j-log4j12)<br>    配置web.xml<br>        配置监听器(org.springframework.web.context.ContextLoaderListener)<br>        通过上下文加载applicationContext.xml<br>        配置前端控制器<br>            class:org.springframework.web.servlet.DispatcherServlet<br>            通过指定init-para来加载spring-mvc.xml<br>        配置字符编码过滤器……<br>    编写实体类、mapper接口、mapper.xml<br>        配置applicationContext.xml<br>        扫包（必要）<br>        配置数据源：<br>            <bean id="datasource" class="com.alibaba.druid.pool.DruidDataSource"> 注入属性</bean><br>        整合mybatis<br>            将mybatis的sqlSessionFactory交给spring管理(class=”org.mybatis.spring.SqlSessionFactoryBean”)<br>                注入属性：数据源,mapper.xml映射文件的路径，配置实体别名<br>            配置mapper接口的包所在位置，让spring容器管理(class=”org.mabatis.spring.mapper.MapperScannerConfigurer”)<br>                注入属性：mapper接口所在位置，sqlSessionFactoryBeanName        !!!!!!注入sqlSessionFactory时不要使用ref，要用value<br>        配置事务管理器<br>            class=”org.springframework.jdbc.datasource.DataSourceTransactionManager”    注入数据源<br>        开启对事务注解的支持：&lt;tx:annotation-driven transaction-manager=”事务管理器的id” /&gt;<br>    配置spring-mvc.xml<br>        扫包（必要）<br>        开启对mvc注解的支持<br>        配置视图解析器：class=”org.springframework.web.servlet.view.InternalResourceViewResolver”<br>            配置前缀，后缀<br>        配置静态资源<br>            配置全局异常处理类时可以在spring的配置文件也可以在springmvc的配置文件</p>
<p>#<strong><em>SpringBoot笔记</em></strong></p>
<p>##微服务<br>    一种架构风格:一个应用应该是一组小型服务，可以通过http进行互通<br>    每一个功能元素最终都是一个可以独立替换和独立升级的软件单元</p>
<p>#<strong>SpringBoot+Thymeleaf</strong> </p>
<p>##<strong>springboot的配置需要注意的地方</strong></p>
<h3 id="在使用webjars之后，在前端页面上引入方式为："><a href="#在使用webjars之后，在前端页面上引入方式为：" class="headerlink" title="在使用webjars之后，在前端页面上引入方式为："></a>在使用webjars之后，在前端页面上引入方式为：</h3><pre><code>&lt;script th:src=&quot;@{webjars/jquert/3.1.0/dist/jquery.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{webjars/bootstrap/4.3.1/css/bootstrap.css}&quot;&gt;
&lt;script th:src=&quot;@{webjars/bootstrap/4.3.1/js/bootstrap.js}&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><p>##<strong>注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span>      <span class="comment">//标注这是一个主程序类，说明是一个springboot应用</span></span><br><span class="line"><span class="meta">@EnbaleAutoConfiguration</span>    <span class="comment">//开启自动配置功能</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>    <span class="comment">//标注这是一个SpringBoot的配置类</span></span><br><span class="line"><span class="meta">@RestController</span>   <span class="comment">//相当于@Controller+@ResponseBody</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">""</span>)    <span class="comment">//将全局配置文件中“prefix”的每一个值,映射到这个组件中 ,需要配置文件处理器,只有这个组件是容器的组件，才能使用容器的功能(需要交给spring容器管理@Component)</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)+<span class="meta">@SpringBootTest</span>    <span class="comment">//搭配使用，springboot的单元测试</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath: xxx.properties"</span>&#125;)        <span class="comment">//加载指定的配置文件</span></span><br><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath: xxx.xml"</span>&#125;)     <span class="comment">//导入spring的配置文件，让配置文件中的内容生效 (类似以前的spring、springmvc的配置文件)</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//声明这是一个配置类，搭配@Bean使用</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">//类似于配置文件中的&lt;bean&gt;&lt;/bean&gt;标签，默认id为方法名</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/09/java基础/" class="article-date">
      <time datetime="2019-07-09T06:36:33.000Z" itemprop="datePublished">2019-07-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/java基础/">java基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#Java基础</p>
<p>##集合</p>
<p>##常见的集合及接口：</p>
<ul>
<li>Map和Collection是所有集合框架的父接口。</li>
<li>Collection接口的子接口有Set和List。</li>
<li>Map接口的实现类主要有：HashMap，HashTable，TreeMap</li>
</ul>
<p>###集合与数组的区别：</p>
<ul>
<li>数组的长度是固定的，集合的长度是可变的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能储存引用数据类型（系统会将基本数据类型自动装箱）。</li>
<li>一个数组储存的数据必须是一个数据类型，集合可以存储不通的数据类型。</li>
</ul>
<p>####ArrayList与LinkedList的区别：</p>
<ul>
<li>ArrayList数组结构，有序。优点：get、set也就是查询速度快；缺点：添加删除慢。</li>
<li>LinkedList双向链表结构，无序。优点：添加删除快；缺点：get、set也就是查询慢；</li>
<li>都允许存储null元素，可重复，都不是线程安全的。</li>
</ul>
<p>####HashSet、TreeSet、LinkedHashSet的区别：</p>
<ul>
<li>如果你需要一个访问快速的Set，你应该使用HashSet；当你需要一个排序的Set，你应该使用TreeSet；当你需要记录下插入时的顺序时，你应该使用LinedHashSet。</li>
<li>HashSet：无序不可重复；可以为null，但只能有一个null；不是同步的。</li>
<li>TreeSet：有序不重复。</li>
<li>LinkedHashSet：遍历集合是，以元素添加的顺序访问集合；迭代性能比HashSet好，插入比HashSet差。</li>
</ul>
<p>####数组List互转：</p>
<ul>
<li>数组转List：Arrays.asList（数组）</li>
<li>List转数组：list.toArray()</li>
</ul>
<p>####HashMap与HashSet的区别：</p>
<ul>
<li>HashMap实现了Map接口，HashSet实现了Set接口。</li>
<li>HashMap存储键值对，HashSet存储对象。</li>
<li>HashMap使用put()添加元素，HashSet使用add()添加元素。</li>
<li>HashMap使用key计算hashcode，HashSet使用成员计算hashcode。</li>
<li>HashMap相较于HashSet较快，使用唯一键获取对象。</li>
</ul>
<p>####HashMap与HashTable的区别：</p>
<ul>
<li>HashMap是线程不安全的，HashTable使用了synchronized关键字，是线程安全的。</li>
<li>HashMap允许null的键和值，HashTable不允许。</li>
<li>HashMap的性能要优于HashTable。</li>
</ul>
<p>####HashMap与TreeMap的区别</p>
<ul>
<li>HashMap非线程安全，TreeMap是线程安全的。</li>
<li>HashMap存取顺序不一定一样，但是取出来的顺序一样</li>
<li>TreeMap是一个有序的Map集合，基于红黑树实现</li>
</ul>
<p>##IO流</p>
<p>####JAVA有几种类型的流</p>
<ul>
<li>字节流，继承自InputStream和OutputStream。</li>
<li>字符流，继承自InputStreamReader和OutputStreamWriter。</li>
</ul>
<p>####字节流与字符流哪个好：</p>
<ul>
<li>大多数情况下使用字节流，因为字节流是字符流的包装，而大多数时候的IO都是直接操作磁盘文件，所以流在传输是都是以字节流的方式进行的。</li>
<li>如果对于操作需要通过IO在内存中频繁处理字符串的情况使用字符流会更好些，因为字符流具备缓冲区，提高了性能。</li>
</ul>
<p>####什么是缓冲区：</p>
<ul>
<li>缓冲区是一块特殊的内存区域，当程序需要频繁的操作一个资源的时候，性能会很低，为了提高性能就可以将一部分数据暂时读写到缓冲区，以后的操作可以直接重缓冲区中读写即可。</li>
<li>对于java的字符流的操作都是在缓冲区操作的，如果我们想在字符流操作中主动将缓冲区刷新到文件可以使用flush()方法。</li>
<li>字节流的操作不会经过缓冲区，是直接操作文件本身；字符流会先经过缓冲区，在通过缓冲区操作文件。</li>
</ul>
<p>####什么事Java序列化，如何实现：</p>
<ul>
<li>序列化就是一种来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络。为了解决在对象流读写时引发的问题（方便网络传输）。</li>
<li>实现java的序列化：将需要被序列化的类实现Serialize接口，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputSream（对象流）对象，使用ObjectOutputSream的wirte（Object obj）方法将obj的对象写出即可。</li>
</ul>
<p>####5种IO模型</p>
<ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>—-每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。</li>
<li>信号驱动</li>
<li>—-信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</li>
<li>多路复用（多个阻塞IO）</li>
<li>—-IO多路复用是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。</li>
<li>异步IO<br>阻塞程度：阻塞IO&gt;非阻塞IO&gt;多路转接IO&gt;信号驱动IO&gt;异步IO，效率是由低到高的。<br>##多线程</li>
</ul>
<p>####线程与进程的区别：<br>线程是操作系统能够进行运算调度的最小资源单位。一个程序必有一个进程，一个进程必有一个线程。不同进程使用不同的内存空间，一个程序的所有线程共用一片相同的内存空间。</p>
<p>####在java中如何实现多线程：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runable接口（无返回值）</li>
<li>实现Callable接口（有返回值）</li>
</ul>
<p>####Thread类的start()和run()方法的区别：</p>
<ul>
<li>start()方法用来启动线程，将线程由创建状态变为就绪状态，。</li>
<li>run()方法当做普通方法调用，run()方法是一个普通方法，当线程start()后，一旦被CPU调度，处于运行状态，线程才会去调用run()。</li>
</ul>
<p>####线程的5种状态</p>
<ul>
<li>新建状态（New）：使用new创建一个线程时，该线程处于新建状态</li>
<li>就绪状态（Runable）：执行start()方法后，该线程处于就绪状态</li>
<li>运行状态（Running）：该线程获得cpu资源后，进入运行状态，执行run()方法</li>
<li>阻塞状态（Blocked）：线程调用sleep(),wait(),suspend()、线程调用一个IO被阻塞的操作、线程试图获得一个被其他线程占用的锁、线程在等待某个触发条件都会导致线程阻塞。</li>
<li>死亡状态（Dead）：run()方法正常退出线程自然死亡、一个未捕获的异常终止了run()方法，导致线程猝死。</li>
</ul>
<p>##JVM</p>
<ul>
<li>jvm的组成<ul>
<li>Class Loader 类加载器:  负责class文件的加载，至于是否可以运行由Execution Engine决定</li>
<li>Native Interface 本地接口:  融合c/c++程序</li>
<li>Method Area 方法区:  所有字段、方法字节码、某些特殊方法(构造函数、接口代码)在此定义。简单说，所有定义的方法信息都保存在此区域。方法区属于共享区间，被所有线程共享。</li>
<li>PC Register 程序计数器:  每个线程都有一个程序计数器，就是一个指针，指向方法区中的字节码(下一个将要执行的指令代码)，由执行引擎读取下一个指令，是一个内存非常小的空间，可以忽略不记。</li>
<li>Native Method Stack 本地方法栈:  在Native  Method Stack中登记native方法，在Execution Engine执行时加载native libraies。</li>
<li>GC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例变量存在堆内存中。</span><br><span class="line">栈管运行，堆管存储。</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>###堆栈<br>    栈:  也叫栈内存，主管java程序的运行，在线程创建时创建，线程结束栈内存页就释放，生命周期跟随线程，是线程私有的，基本类型的变量和对象的引用都是在栈内存中分配。对于栈来说，不存在垃圾回收问题，<br>    栈中存储:<br>        1)、本地变量:    输入参数，输出参数，方法内变量。<br>        2)、栈操作:     记录出栈，入栈的操作。<br>        3)、栈帧数据:       包括类文件，方法等(当A方法被调用时就会产生栈帧F1，B….F2，………，并且被压入栈中，遵循先进后出的原则)。</p>
<pre><code>堆:  </code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/08/Linux笔记/" class="article-date">
      <time datetime="2019-07-08T08:22:10.000Z" itemprop="datePublished">2019-07-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/Linux笔记/">Linux笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#Linux的优点<br>    安全性、硬件要求低、开源免费、稳定性、</p>
<p>###linux常见命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装软件: yum install xxx</span><br><span class="line">卸载软件: yum remove xxx</span><br><span class="line">搜索软件: yum serach xxx</span><br><span class="line">清理缓存:yum clean packages</span><br><span class="line">列出安装列表: yum list</span><br><span class="line">查看软件包信息: yum info xxx</span><br><span class="line"></span><br><span class="line">添加用户: useradd xxx   /   adduser xxx</span><br><span class="line">切换用户: su xxx</span><br><span class="line">删除用户: userdel xxx(先退出再删除)</span><br><span class="line"></span><br><span class="line">##防火墙</span><br><span class="line">安装防火墙: yum install firewalld</span><br><span class="line">防火墙:操作 systemctl     start/stop/restart/disable(禁止开启启动)/status(查看状态)    firewalld.service</span><br><span class="line">开放端口: vim /etc/sysconfig/iptables 在前面添加-A INPUT -p tcp -m tcp --dport 4000 -j ACCEPT 然后保存重启</span><br></pre></td></tr></table></figure>

<p>###文件目录</p>
<ul>
<li>／dev 设备目录</li>
<li>／etc/ 系统配置及服务配置文件，比如我们之前修改网卡配置</li>
<li>／proc 显示内核及进程信息的虚拟文件系统</li>
<li>／tmp 临时文件目录</li>
<li>／home 普通用户家目录 :在公司中开发人员能拿到的都是普通用户，运维人员会创建很多普通用户，那么这些用户的信息就放在这下面</li>
<li>／root 超级管理员家目录</li>
<li>／var 变化的目录，一般是日志文件（／var／log），cache目录。／var／log／messages，／var/log／secure</li>
<li>／usr 用户程序及数据，帮助文件，二进制命令等目录（usr／local/），一般我们安装jdk、mysql、maven等都是放在这儿</li>
<li>／bin 普通用户命令的目录</li>
<li>／sbin 和／usr／sbin／：超级用户命令的目录</li>
</ul>
<p>###文件操作命令</p>
<pre><code>查看目录下面的文件:   ls、ll、ll -h 
新建文件:   touch
新建文件夹:    mkdir
删除文件:    rm -f 递归删除文件夹   rm -rf 强制递归删除文件夹
进入目录:    cd ~ 当前用户的根目录   cd / 根目录    cd .. 上级目录
查看当前目录: pwd
复制: cp
移动(重命名):    mv a/b/xxx.txt a/c/xxx.txt   mv a/b/xxx.txt a/b/yyy.txt
从尾部读取:  tail -f xxx.txt
从头部读取:  head xxx.txt (隐藏后面部分)   more xxx.txt(按enter可以往下读取一行)
读取整个文件: cat xxx.txt
按住上下箭头移动读取: less xxx.txt(按q退出)
模糊查询(ab):   grep ab -n(显示行数) xxx.txt 
统计行数:  cat xxx.txt | wc -l(统计个数)
查找文件:   find /a/xxx.txt
压缩: tar -z(有gzip属性的需要使用)  c(建立压缩文档) v(显示过程) f(表示用压缩档案的名称作为压缩文件的名称) /tmp/xmcc.tar.gz -C /usr/test xmcc.txt 将usr下的test文件夹中的文本压缩到tmp下面 跨目录才会使用 -C 同级目录下的俩个文件夹 压缩不需要 -C
解压: -z x(表示解压) v f</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mysql笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/01/mysql笔记/" class="article-date">
      <time datetime="2019-07-01T07:18:51.000Z" itemprop="datePublished">2019-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/mysql笔记/">mysql笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>###常见数据库语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#如果存在数据库进行删除操作</span><br><span class="line">drop database if exists &apos;数据库名&apos;;</span><br><span class="line">#创建数据库</span><br><span class="line">create database&apos; 数据库名&apos;</span><br><span class="line">#条件查询：</span><br><span class="line">select * from table1 where &apos;范围&apos;</span><br><span class="line">#插入：</span><br><span class="line">insert into table1(field1,field2) values(value1,value2)</span><br><span class="line">#删除：</span><br><span class="line">delete from table1 where &apos;范围&apos;</span><br><span class="line">#更新：</span><br><span class="line">update table1 set field1=value1 where &apos;范围&apos;</span><br><span class="line">#查找：</span><br><span class="line">select * from table1 where field1 like ’%value1%’</span><br><span class="line">#排序：</span><br><span class="line">select * from table1 order by field1,field2 [desc]</span><br><span class="line">#总数：</span><br><span class="line">select count(*) as &apos;别名&apos; from table1</span><br><span class="line">#求和：</span><br><span class="line">select sum(field1) as &apos;别名&apos; from table1</span><br><span class="line">#平均：</span><br><span class="line">select avg(field1) as &apos;别名&apos; from table1</span><br><span class="line">#最大：</span><br><span class="line">select max(field1) as &apos;别名&apos; from table1</span><br><span class="line">#最小：</span><br><span class="line">select min(field1) as &apos;别名&apos; from table1</span><br><span class="line">#去重: </span><br><span class="line"> select distinct field1 as &apos;别名&apos; from table1</span><br><span class="line">#注:如果是distinct 多列 是以多列一起判断是否重复</span><br><span class="line">#分组: </span><br><span class="line"> select * from table1 group by xxx</span><br></pre></td></tr></table></figure>

<p>####列操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &apos;表名&apos; ADD COLUMN &apos;字段名&apos; &apos;类型&apos;(&apos;长度&apos;);</span><br><span class="line">#eg.</span><br><span class="line">ALTER TABLE sing ADD COLUMN s_level TINYINT(1);</span><br><span class="line">#删除列：</span><br><span class="line">alter table &apos;表名&apos; drop column &apos;列名&apos;;</span><br><span class="line">#修改列名MySQL：</span><br><span class="line"> alter table &apos;表名&apos; change &apos;原名&apos; &apos;新名&apos; int;</span><br><span class="line">#修改列属性：</span><br><span class="line">alter table &apos;表&apos; modify name varchar(22);</span><br></pre></td></tr></table></figure>

<p>####建表操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sing(</span><br><span class="line">s_num VARCHAR(5) NOT NULL UNIQUE COMMENT &apos;身份证号,这儿为了方便以5位算&apos;,</span><br><span class="line">s_beginDate DATE COMMENT &apos;入班时间&apos;</span><br><span class="line">#指定存储引擎为INNODB(这个在优化的时候会学习)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dance(</span><br><span class="line">d_num VARCHAR(5) NOT NULL UNIQUE COMMENT &apos;身份证号,这儿为了方便以5位算&apos;,</span><br><span class="line">d_beginDate DATE COMMENT &apos;入班时间&apos;,</span><br><span class="line">d_level TINYINT(1) COMMENT &apos;0初级，1中级，2高级&apos;</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h3 id="DROP、DELETE、TRUNCATE三者的区别"><a href="#DROP、DELETE、TRUNCATE三者的区别" class="headerlink" title="DROP、DELETE、TRUNCATE三者的区别"></a>DROP、DELETE、TRUNCATE三者的区别</h3><pre><code>drop:删除数据与表结构，无法回滚
truncate:清空数据，速度快。不可回滚，实质是删除表后重新创建表结构
delete:逐行删除数据，有日志记录，可回滚</code></pre><p>###case when then else end<br>    case :指定字段<br>    when:当什么条件<br>    then:满足上面的条件 就干什么<br>    else:前面的条件都不满足<br>    end:结束语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select s_sum, case s_level</span><br><span class="line">when 1 then &apos;初级&apos;</span><br><span class="line">when s_level=2 then &apos;中级&apos;</span><br><span class="line">else &apos;高级&apos;</span><br><span class="line">end &apos;等级&apos;</span><br><span class="line">from sing</span><br></pre></td></tr></table></figure>

<p>###视图View<br>    视图就是一条查询语句执行返回的结果集，目的是为了隐藏部分数据或者减少联表查询而创建的一张表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view first_view (s_id,s_name,c_id,c_name)</span><br><span class="line">as select s_id,s_name,c_id,c_name </span><br><span class="line">from stu s join class c on s.s_id=c.c_id</span><br></pre></td></tr></table></figure>

<p>####视图优缺点:<br>    方便操作，特别是查询；更加安全，可以隐藏数据。<br>    但是性能可能会变慢；更改原表结构都需要更改视图。</p>
<p>###触发器Trigger</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create trigger trigger_name</span><br><span class="line">before delete #指定触发时机</span><br><span class="line">on table_name for each row #对table_name的每一行</span><br><span class="line">update table_name set #old表示删除前的行数据 如果是修改的old表示修改前 new表示修改后</span><br><span class="line">s_cid=null where s_cid=old.c_id</span><br></pre></td></tr></table></figure>

<pre><code>MySQL可以创建以下六种触发器：
BEFORE INSERT,BEFORE DELETE,BEFORE UPDATE
AFTER INSERT,AFTER DELETE,AFTER UPDATE</code></pre><p>####触发器缺点:<br>    1、如果需要变动整个数据集而数据集数据量又较大时，触发器效果会非常差<br>    2、对于批量操作并不适合使用触发器 使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是设计到多个触发器的情况 协同开发时，写业务层代码如果不清楚数据库 触发器的细节，容易搞不清到底触发了那些触发器 大量使用触发器会导致代码结构容易被打乱，阅读源码困难<br>    3、会占用物理内存</p>
<p>###存储过程<br>    优点:<br>        IO非常耗费资源，使用存储过程可以减少java程序与数据库的交互次数<br>    缺点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#存储过程创建</span><br><span class="line">#DELIMITER修改语句结束符为$$ 因为mysql是;结尾 </span><br><span class="line">#但是存储过程是多个语句集 在其中每一个sql都需要;结尾 </span><br><span class="line">#如果我们不修改遇到分号就结束了就不是完整的存储过程了</span><br><span class="line">DELIMITER $$</span><br><span class="line">#如果存在这个存储过程就删除</span><br><span class="line">DROP PROCEDURE IF EXISTS `MyProcedure01`$$</span><br><span class="line">#创建存储过程</span><br><span class="line"># DEFINER=`root`@`localhost`： 指定IP与用户</span><br><span class="line">#PROCEDURE：存储过程关键字 </span><br><span class="line">#MyProcedure01:存储过程名称      ()说明没有参数，跟java方法类似</span><br><span class="line">CREATE [DEFINER=`root`@`localhost`] PROCEDURE `MyProcedure01`()</span><br><span class="line">#开始 可以看成java方法的&#123;</span><br><span class="line">BEGIN</span><br><span class="line">#DECLARE：定义变量关键字  定义一个int类型的变量test 相当于int test</span><br><span class="line">	DECLARE test INT;</span><br><span class="line">#设置test的值为1  相当于test=1</span><br><span class="line">	SET test:=1;</span><br><span class="line">#查询test的值  相当于System.out.println(test);</span><br><span class="line">	SELECT test;</span><br><span class="line">#结束 可以看成java方法的 &#125;</span><br><span class="line">    END$$</span><br><span class="line">#存储过程写完了 需要把结束符号换回来</span><br><span class="line">DELIMITER ;</span><br><span class="line">#调用存储过程</span><br><span class="line">CALL MyProcedure01();</span><br></pre></td></tr></table></figure>

<p>####使用mybatis调用存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#编写取消订单的存储过程</span><br><span class="line">DELIMITER $$</span><br><span class="line">#输入参数为订单order_id 输出参数为result 1 代表存储过程成功 -1代表存储过程出现异常</span><br><span class="line">CREATE PROCEDURE cancel_order(IN order_id VARCHAR(30),OUT result INT)</span><br><span class="line">BEGIN </span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET result:=-1;#如果出现异常设置返回值为-1</span><br><span class="line">START TRANSACTION;#开启事务</span><br><span class="line">SET result:=1;#设置初始值 这里设置为1</span><br><span class="line">UPDATE xmcc_order SET o_statu=1 WHERE o_id=order_id; #修改订单状态</span><br><span class="line">     BEGIN </span><br><span class="line">	  DECLARE done INT DEFAULT TRUE;#定义变量done用来判断</span><br><span class="line">	  DECLARE product_id VARCHAR(30); #定义变量 来接收游标的商品id</span><br><span class="line">	  DECLARE quantity_1 INT; #定义变量来接收游标的商品数量</span><br><span class="line">	  #定义游标 存储根据订单id查询到订单项中的商品id与数量</span><br><span class="line">	  DECLARE cur CURSOR FOR SELECT p_id,quantity FROM xmcc_orderdetail WHERE o_id=order_id;</span><br><span class="line">	  #当游标循环结束 设置done的值为false</span><br><span class="line">	  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done:=FALSE;</span><br><span class="line">	  OPEN cur;#打开游标</span><br><span class="line">	  WHILE done DO #循环</span><br><span class="line">	  FETCH cur INTO product_id,quantity_1;#将游标的值设置到变量中</span><br><span class="line">	  IF done THEN #判断 不然会多修改一次</span><br><span class="line">	  UPDATE xmcc_product SET p_stock=p_stock+quantity_1 WHERE p_id=product_id;</span><br><span class="line">	  END IF;</span><br><span class="line">	  END WHILE;</span><br><span class="line">	  CLOSE cur;</span><br><span class="line">     END ;</span><br><span class="line"> IF result=1 THEN #没有出现异常就提交</span><br><span class="line"> COMMIT;</span><br><span class="line"> ELSE </span><br><span class="line"> ROLLBACK;</span><br><span class="line"> END IF;</span><br><span class="line"> END ; $$</span><br><span class="line"> #测试</span><br><span class="line">CALL cancel_order(&apos;20001&apos;,@result);</span><br><span class="line">#查看结果</span><br><span class="line">SELECT @result</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"cancelOrder"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>  <span class="attr">statementType</span>=<span class="string">"CALLABLE"</span>&gt;</span></span><br><span class="line">    &#123;call cancel_order(</span><br><span class="line">      <span class="comment">&lt;!--只需要对应传递过来的map key的名字就可以了 一般都是用map来处理 当然其他也是可以的--&gt;</span></span><br><span class="line">      #&#123;order_id,mode=IN,jdbcType=VARCHAR&#125;,</span><br><span class="line">      #&#123;result,mode=OUT,jdbcType=INTEGER&#125;</span><br><span class="line">      )&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"order_id"</span>,<span class="string">"20001"</span>);</span><br><span class="line">map.put(<span class="string">"result"</span>,<span class="number">3</span>);<span class="comment">//使用3来查看是否更改了值</span></span><br><span class="line">xxxMapper.cancelOrder(map);</span><br><span class="line">log.info(<span class="string">"存储过程调用成功,结果为:&#123;&#125;"</span>,map.get(<span class="string">"result"</span>));</span><br></pre></td></tr></table></figure>

<p>###索引<br>    优点:<br>        1.索引大大减少了存储引擎需要扫描的数据量<br>        2.索引可以在某些时候帮助减少排序的时间<br>        3.索引可以把随机I/O转为顺序I/O<br>        一句话，大大增加了检索效率<br>    缺点:<br>        1.会降低维护效率，因为索引是通过一定的算法，算出一个值后分类放在某个位子，那么每次更新又需要去算一次<br>        2.索引占物理空间，算出了数据结构，总得有个地方放吧</p>
<p>####索引的类型</p>
<ul>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询、列值唯一（可为NULL）</li>
<li>主键索引：加速查询、列值唯一（不可为NULL）、一张表只能有一个主键索引</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
<li>***索引合并：使多个单列索引组合搜索</li>
<li>***select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖<br>####索引失效的情况</li>
</ul>
<ol>
<li>查询时不按组合索引的顺序</li>
</ol>
<ul>
<li>使用or的时候or的所有列都需要建立索引</li>
<li>使用like进行模糊查询使用了前%</li>
<li>字符型不加引号，数据库转换成了数值型</li>
<li>sql中使用函数，运算操作</li>
<li>mysql的扫描全盘比索引快</li>
<li>对于内容基本重复的列，禁止建立索引<br>##Mysql优化<ul>
<li>选择正确的存储引擎(MyISAM、InnoDB、MEMORY、MERGE等，优化第一步)<br>   MyISAM(mysql5.5以前默认):<pre><code>1.)不支持事务、不支持外键，支持全文索引
2).只支持表级锁，会保存表的具体行数
3).没有事务日志，故障恢复数据较麻烦
4).分区存放文件，平均分配IO，不用花费资源去处理事务，效率较高</code></pre>   InnoDB:<pre><code>1).支持事务、支持外键，5.6以后才支持全文索引
2.支持行级锁与表级锁，不会保存表的具体行数
3).花费资源去处理事务，效率比不上MyISAM
4).有事务日志，恢复数据较方便</code></pre>  第一步回答:首先是存储引擎的选择，因为xxxxxx，所以如果应用中需要执行大量的SELECT查询，对事务要求又不高，那么MyISAM好的选择，有事务、行级锁、恢复数据要求一般选择InnoDB；不用事务，count计算次数多的时候用myisam，对可靠性要求高的时候用innodb，推荐使用innodb；</li>
<li>锁选择<pre><code>从粒度分:
    1)、表级锁:
          锁住整张表，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
    2)、行级锁:
          开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高
从类型分:
    1)、读锁（共享锁）:
            两边都可以并发读取数据，但任何事务都不可以修改数据，直到已释放所有共享锁
    2)、写锁（排他锁）
            如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据</code></pre></li>
</ul>
</li>
<li>避免阻塞与死锁(优化第二步)<br>   1、数据库阻塞的现象：第一个连接占有资源没有释放，而第二个连接需要获取这个资源。如果第一个连接没有提交或者回滚，第二个连接会一直等待下去，直到第一个连接释放该资源为止。对于阻塞，数据库无法处理，所以对数据库操作要及时地提交或者回滚。造成的原因有:网络延迟、锁的范围选择有问题等。<br>  避免阻塞: <pre><code>最直接最简单的方法就是把表的数据量变小
当然sql语句调优、提高代码质量等都是很重要的</code></pre>  2、死锁: 所谓死锁<deadlock>: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象(跟java线程死锁类似)，表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB<br>  避免死锁:<pre><code>1).首先在innodb搜索引擎中，会根据算法主动进行部分死锁的检测与释放，比如上面的例子自动释放。
2).尽量以固定的顺序访问表和行，因为一个先锁A 在去B ，一个先锁B 在去A 就容易发生死锁
3).大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
4).在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。(牺牲效率，不建议)
5).为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大（后面学习索引）</code></pre>接着上面的优化回答:选择了合适的搜索引擎以后，在实际操作中，通过xxxxx，尽量去避免数据库阻塞与死锁的发生。</deadlock></li>
<li>表设计(优化第三步)<br>…………………………….<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">面试问:请谈谈mysql优化？</span><br><span class="line">建议回答:我觉得mysql优化的涉及的面太广了，我就把我知道的都说一下吧!</span><br><span class="line"></span><br><span class="line">首先应该选择合适的存储引擎，</span><br><span class="line">    一般常用的是MyISAM与INNODB，xxxx区别，所以xxxxx情况选择xxxx</span><br><span class="line">    </span><br><span class="line">其次，在项目对mysql并发操作中经常出现阻塞、死锁等现象，那么应该xxxxx尽量去避免</span><br><span class="line"></span><br><span class="line">然后在数据库表设计方面:</span><br><span class="line">	首先：应该了解清楚需求</span><br><span class="line">    其次：对表的逻辑结构设计的时候，应该尽量采用三范式来减少冗余字段（减少内存浪费），与避免更新异常</span><br><span class="line">    但是，根据业务分析也可以在适当地方采取反范式的设计，采用空间换时间来提升查询效率</span><br><span class="line">    然后:表的命名应该尽量xxx，在字段选择上xxxxx，比如当是整数xxxx,当时小数xxxx，当是字符串xxxx ，日期xxxx</span><br><span class="line">使用索引:</span><br><span class="line">    1.应该根据业务需要，在更新较少，辨识度较高，查询较多等等xxx的列上建立索引，（数据结构，优缺点自己组织一下语言）</span><br><span class="line">    2.在日常书写sql的时候，多用explain去分析执行计划, 避免索引失效（sql语句优化说得越多越好）</span><br><span class="line">    3.	慢查询定位(最好能说出之前我们项目中使用druid的时候配置的慢查询)</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/01/面试题/" class="article-date">
      <time datetime="2019-07-01T07:02:15.000Z" itemprop="datePublished">2019-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/面试题/">面试题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#JVM原理</p>
<p>#红黑树</p>
<p>#分布式和微服务是不是同一个东西</p>
<p>#多线程的实现方式</p>
<p>#描述一下线程死锁的情况</p>
<p>#####以下对HTTP协议描述正确的是：<br>    A. HTTP是有序连接的<br>    B.HTTP是媒体耦合的<br>    C.HTTP是无状态<br>    D.HTTP基于客户端/服务端（C/S）架构模型，通过不可靠链接来交换信息<br>    分析:<br>    A:HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间<br>    B:HTTP是媒体独立的：意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型<br>    D:HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。<br>计算机网络功能主要包括实现资源共享，实现数据信息的快速传递，提高可靠性，提供负载均衡与分布式处理能力，集中管理及综合信息服务。<br>网络协议三要素为：语法、语义、同步</p>
<p>###指令寻址的两种方式<br>    一种是顺序寻址方式，指令地址由程序计数器给出。<br>    另一种是跳跃寻址方式，指令地址由指令本身给出。</p>
<p>##String常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str =<span class="string">""</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">","</span>).length);</span><br><span class="line"><span class="comment">//输出结果为1，注可以对""的字符串进行操作，只有当为null才会报空指针</span></span><br></pre></td></tr></table></figure>

<p>##sleep、wait、yield、join<br>    1.sleep()方法<br>    在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。</p>
<pre><code>sleep()使当前线程进入阻塞状态，在指定时间内不会执行。

2.wait()方法

在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。

当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。

唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。

waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。

3.yield方法 

暂停当前正在执行的线程对象。

yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。

yield()只能使同优先级或更高优先级的线程有执行的机会。 

4.join方法

等待该线程终止。

等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</code></pre><p>##阅读下列程序，正确的输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“I’m A <span class="class"><span class="keyword">class</span> ”)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    <span class="title">static</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">static</span> A”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“I’m B <span class="class"><span class="keyword">class</span>”)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    <span class="title">static</span></span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">static</span> B”);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案:static A static B I’m A class I’m B class</span></span><br><span class="line"><span class="comment">//执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法</span></span><br><span class="line"><span class="comment">//Java类初始化顺序：父类静态变量-&gt; 父类静态代码块-&gt; 子类静态代码块-&gt; 父类非静态代码块 -&gt;父类构造函数 -&gt;子类非静态代变量 -&gt;子类非静态代码块-&gt; 子类构造器</span></span><br></pre></td></tr></table></figure>

<p>###HashMap和Hashtable<br>    HashTable 使用 synchronized 来进行同步，线程安全，速度慢，key/value不允许为null。<br>    HashMap 非同步，速度快，key/value允许为null。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/29/SpringBoot学习笔记/" class="article-date">
      <time datetime="2019-06-29T07:11:05.000Z" itemprop="datePublished">2019-06-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/SpringBoot学习笔记/">SpringBoot学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#<strong>SpringBoot笔记</strong></p>
<p>##微服务<br>    一种架构风格:一个应用应该是一组小型服务，可以通过http进行互通<br>    每一个功能元素最终都是一个可以独立替换和独立升级的软件单元</p>
<p>##常用注解 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>      <span class="comment">//标注这是一个主程序类，说明是一个springboot应用</span></span><br><span class="line"><span class="meta">@EnbaleAutoConfiguration</span>    <span class="comment">//开启自动配置功能</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>    <span class="comment">//标注这是一个SpringBoot的配置类</span></span><br><span class="line"><span class="meta">@RestController</span>   <span class="comment">//相当于@Controller+@ResponseBody</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">""</span>)    <span class="comment">//将全局配置文件中“prefix”的每一个值,映射到这个组件中 ,需要配置文件处理器,只有这个组件是容器的组件，才能使用容器的功能(需要交给spring容器管理@Component)</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)+<span class="meta">@SpringBootTest</span>    <span class="comment">//搭配使用，springboot的单元测试</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath: xxx.properties"</span>&#125;)        <span class="comment">//加载指定的配置文件</span></span><br><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath: xxx.xml"</span>&#125;)     <span class="comment">//导入spring的配置文件，让配置文件中的内容生效 (类似以前的spring、springmvc的配置文件)</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//声明这是一个配置类，搭配@Bean使用</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">//类似于配置文件中的&lt;bean&gt;&lt;/bean&gt;标签，默认id为方法名</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##SpringBoot自动配置原理</span><br><span class="line"></span><br><span class="line">1. SpringBoot启动是加载主配置类，开启了配置功能`@EnbaleAutoConfiguration`</span><br><span class="line"></span><br><span class="line">   - `@EnbaleAutoConfiguration`的作用是利用`AutoConfigurationImportSelector`给容器导入一些组件:</span><br><span class="line">   - 可以查看`selectImports()`方法的内容</span><br><span class="line">   - `List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);`</span><br><span class="line">   - `SpringFactoriesLoader.loadFactoryNames()`扫描所有jar</span><br><span class="line">   - 包类路径下的META-INF/spring.factories，把扫描到的文件的内容包装成properties对象</span><br><span class="line">   - 从properties中获取到`EnableAutoConfiguration.class`(类名)对应的值，然后把他们添加到容器中</span><br><span class="line">   - *总结为:将类路径下META-INF/spring.factories里面配置所有的EnableAutoConfiguration的值加入到了容器中*</span><br><span class="line"></span><br><span class="line">2. spring.factories</span><br><span class="line">       ```properties</span><br><span class="line">       # Auto Configure</span><br><span class="line">       org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">       org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">       org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration</span><br><span class="line">       /*每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置*/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>每一个自动配置类进行自动配置功能</p>
</li>
<li><p>以<code>HttpEncodingAutoConfiguration</code>类为例，解释自动配置原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//表示这是一个配置类，类似配置文件，也可以给容器添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpProperties.class&#125;)  <span class="comment">//启用指定类的ConfigurationProperties功能，将配置文件中对应的值和HttpEncodingProperties绑定，并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line">    <span class="comment">//Spring底层有一个@Conditional注解，根据不停条件，如果满足指定的条件，整个配置类里面的配置才会生效</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)       <span class="comment">//判断当前应用是否是web</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CharacterEncodingFilter.class&#125;)        <span class="comment">//判断当前项目有没有CharacterEncodingFilter类，SpringMVC进行解决乱码的过滤器</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>,value = &#123;<span class="string">"enabled"</span>&#125;,matchIfMissing = <span class="keyword">true</span>)       <span class="comment">//判断配置文件中是否存在spring.http.encoding.value的配置，如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使配置文件中不配置此属性，也是默认生效的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;  <span class="comment">//已经和SpringBoot的配置文件映射了</span></span><br><span class="line">    <span class="comment">//只有一个有参构造器的情况下，参数的值会从容器中拿</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器添加一个组件，组件的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>   <em>根据当前不同条件判断，决定这个配置类是否生效，一旦生效，这个配置类就会给容器添加各种属性，组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是个配置文件绑定的</em></p>
</li>
<li><p>所有在配置文件能配置的熟悉都是在xxxProperties类中封装着的，配置文件能配置什么可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)    <span class="comment">//从配置文件获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>##SpringBoot的精髓<br>1)、SpringBoot启动时会加载大量的自动配置类<br>2)、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类<br>3)、看自动配置类中到底配置了那些组件(如果我们需要的组件有，就不需要再来配置了)<br>4)、给容器中自动配置类添加组件的时候，会从Properties雷总获取默写属性，我们可以在配置文件中去指定这些属性的值<br>xxxxProperties:封装配置文件中的相关属性——&gt;xxxxAutoConfiguration:自动配置类——&gt;给容器添加组件<br>###<strong>自动配置类必须在一定条件下才能生效(@Conditional及其衍生注解进行判断)</strong><br>可以通过启用SpringBoot的debug=true属性，让控制台打印自动匹配值报告，知道哪些自动配置类生效</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line">Positive matches:   <span class="comment">//已启用的</span></span><br><span class="line">-----------------</span><br><span class="line">   CodecsAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">http</span>.<span class="title">codec</span>.<span class="title">CodecConfigurer</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class">      </span></span><br><span class="line">Negative matches:   //未启用的，没有匹配成功的自动配置类</span><br><span class="line">-----------------</span><br><span class="line">ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required <span class="class"><span class="keyword">class</span> '<span class="title">javax</span>.<span class="title">jms</span>.<span class="title">ConnectionFactory</span>' (<span class="title">OnClassCondition</span>)</span></span><br></pre></td></tr></table></figure>

<p>##SpringBoot与日志<br>    SpringBoot底层是使用slf4j+logback的方式记录进行日志记录<br>    SpringBoot也把其他的日志都替换成了slf4j(使用替换包<br>   <strong>SpringBoot能自动适配所有日志，而且底层使用的是slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志包排除掉</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.ws<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ws-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用log配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">&#123;com.zz:</span> <span class="string">trace&#125;</span></span><br><span class="line">    <span class="comment">#不指定路径在当前项目或指定目录下生成log日志，需要指定文件名，path和file只能存在一个  </span></span><br><span class="line"><span class="attr">  path:</span> <span class="attr">G:/springboot.log</span>    </span><br><span class="line">    <span class="comment">#在指定路径下创建spring.log作为默认日志文件,当前为项目所在盘的/spring/log文件夹下</span></span><br><span class="line"><span class="attr">  file:</span>  <span class="string">/spring/log</span>  </span><br><span class="line">     <span class="comment">#控制台输出格式  ：时间格式 [线程名] 左对齐 日志级别 全类名 字数 日志信息 换行  </span></span><br><span class="line"><span class="attr">    console:</span> <span class="string">"%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n"</span> </span><br><span class="line"><span class="attr">    file:</span> <span class="string">"%d&#123;yyyy-MM-dd&#125; ==== [%thread] == %-5level === %logger&#123;50&#125; ==== %msg%n"</span></span><br></pre></td></tr></table></figure>

<p>##SpringBoot的Web开发</p>
<p><strong>SpringBoot对静态资源的映射规则</strong>    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**	WebMvcAuotConfiguration：</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">                CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">                <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">"/webjars/**"</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">"classpath:/META-INF/resources/webjars/"</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">                &#125;</span><br><span class="line">                String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">                    <span class="comment">//静态资源文件映射</span></span><br><span class="line">                <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射欢迎页面</span></span><br><span class="line">         <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="keyword">this</span>.getWelcomePage(), <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">        &#125;</span><br><span class="line">**</span><br></pre></td></tr></table></figure>

<p>###使用webjars的方式引入jq、bootstrap等静态资源<br>    导入的资源jar包结构如下，springboot已经有了相关映射配置(详见上段代码)<br>    使用的时候只需要请求“webjars/jquery/3.1.1/jquery.js”即可成功<br>   <img src="H:/MarkEditor/_image/2019-06-15-19-34-51.jpg" alt></p>
<p>###访问当前项目的任何资源都去静态资源文件夹去映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"classpath:/META-INF/resources/"</span>, </span><br><span class="line"><span class="string">"classpath:/resources/"</span>,</span><br><span class="line"><span class="string">"classpath:/static/"</span>, </span><br><span class="line"><span class="string">"classpath:/public/"</span> </span><br><span class="line"><span class="string">"/"</span>：   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   以上所有目录的静态资源都能被springboot映射</span></span><br><span class="line"><span class="comment">*   / 表示当前项目的根路径</span></span><br><span class="line"><span class="comment">*   欢迎页所在位置应该为以上文件夹的index.html文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>##Thymeleaf<br>   SpringBoot内置的tomcat默认不支持jsp，推荐使用Thymeleaf</p>
<p>####<strong>1、引入Thymeleaf(maven引入starter)</strong></p>
<p>####<strong>2、  在页面上引入(引入有语法提示)<code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></strong></p>
<p>####<strong>3、 Thymeleaf的语法规则:</strong><br>    1)、th:text  改变当前元素的文本内容<br>        th:任意html属性来替换原来的属性的值<br>    2)、表达式<br>        ${…}:OGNL实现，获取对象的属性、调用方法、使用内置的基本对象、内置的工具对象<br>        <em>{…}:选择表达式，和${}功能上基本一致的，配合th:object使用 th:object=${user}; *{name},</em>{sex}<br>        #{…}:获取国际化内容<br>        @{…}:定义url<br>        ~{…}:片段引用</p>
<p>##<strong>springboot的配置需要注意的地方</strong></p>
<p>###在使用webjars之后，在前端页面上引入方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script th:src=&quot;@&#123;webjars/jquert/3.1.0/dist/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;webjars/bootstrap/4.3.1/css/bootstrap.css&#125;&quot;&gt;</span><br><span class="line">&lt;script th:src=&quot;@&#123;webjars/bootstrap/4.3.1/js/bootstrap.js&#125;&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>##SpringBoot对SpringMVC的自动配置<br> <a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-developing-web-applications.html" target="_blank" rel="noopener">官方文档</a></p>
<p>###SpringBoot自动配置好了SpringMVC<br>以下是SpringBoot对SpringMVC的部分默认配置:<em>具体配置在org.springframework.boot.autoconfigure.web包中</em></p>
<ul>
<li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.<br><em>自动配置了ViewResolver(视图解析器:根据方法的返回值得到视图对象View，视图对象决定如何渲染_(转发，重定向))；ContentNegotiatingViewResolver : 组合所有的视图解析器，自动的将其组合进来</em></li>
<li>Support for serving static resources, including support for WebJars (covered later in this document)).<br><em>静态资源文件夹路径和webjars</em></li>
<li>Automatic registration of Converter, GenericConverter, and Formatter beans.<br><em>自动注册了Converter(转换器)，Formatter(格式化器，如日期格式化)</em></li>
<li>Support for HttpMessageConverters (covered later in this document).<br><em>HttpMessageConverters(消息转换器，SpringMVC用来转换Http请求和响应的，HttpMessageConverters是从容器中确定的)</em></li>
<li>Automatic registration of MessageCodesResolver (covered later in this document).<em>定义错误代码生成规则</em></li>
<li>Static index.html support.  <em>静态首页访问</em></li>
<li>Custom Favicon support (covered later in this document).  <em>favicon.ico图标</em></li>
<li>Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).<br>####扩展SpringMVC<br> 编写配置类，使用@Configuration注解的类，是WebMvcConfigurer类型的；不能标注@EnableWebMvc</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/logout"</span>).setViewName(<span class="string">"admin/success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理:<br>    1)、WebMvcConfiguration是springboot的自动配置类<br>    2)、在做其他自动配置时会导入:@Import(EnableWebMvcConfiguration.class)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingWebMvcConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)    <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  3)、容器中所有的WebMvcConfigurer都会一起起作用<br>  4)、我们自己写的配置类也会被调用</p>
<p>效果:SpringMVC的自动配置和扩展配置都会起作用</p>
<p>###全面接管SpringMVC(默认配置不会起作用，完全由自己配置SpringMVC)<br>@EnableWebMvc:</p>
<p>###SpringBoot定制错误页面或json数据<br>    1)、有模板引擎的情况下，在模板引擎文件夹下创建error文件夹，将对应的错误状态码.html放入其中(可以命名为4xx.html,5xx.html，优先寻找精确页面)<br>    2)、</p>
<p>###SpringBoot指定运行环境<br>spring.profiles.active=dev/prod</p>
<p>###如何理解前后端分离<br>主要指开发阶段，部署时候分离不重要</p>
<ol>
<li>前端不需要由服务器生成动态页面，只需要调用后端提供的接口获取数据，实现前端页面的逻辑交互</li>
<li>后端实现业务逻辑，只提供API接口地址和返回json数据。<br>优点：<br>前后端解耦，动态资源和静态资源分离，提高了性能和扩展性<br>后端可以使用多种语言实现，不提供任何与界面相关的内容，提供的数据可以用于移动端和浏览器端<br>减少了服务器的压力<br>###前后端分离如何代替session</li>
<li>使用token：<br>登录成功后，服务器端生成一个token，把userid和token放入缓存中如redis，然后把token返回给前端，前端储存在本地，之后的每次请求都带上token，服务器判断当前token时候有效</li>
<li>使用cookie：<br>登录成功后，将cookie写到客户端，返回前端ok，</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/29/学习笔记/" class="article-date">
      <time datetime="2019-06-29T07:02:15.000Z" itemprop="datePublished">2019-06-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/学习笔记/">学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#<strong>SSM笔记</strong></p>
<p>##AOP：<br>    使用注解需要在切面类上添加<br>    @Aspect            声明是一个切面类<br>    @Component<br>    @EnableAspectJAutoProxy            开启自动代理<br>    使用配置文件需要引入org.aspectj.aspectjweaver<br>    <a href="aop:config" target="_blank" rel="noopener">aop:config</a>        父级标签<br>        &lt;aop:aspect id=”” ref=”引入切面类bean的id”&gt;<br>            &lt;aop:before method=”切面类中的某个方法名（只需要方法名，不要括号）”  pointcut=”execution（* <em>..</em>.<em>（..））”/&gt;<br>            &lt;aop:around method=”printEditLog” pointcut=”execution(</em> <em>..</em>ServiceImpl.edit(..))”&gt;<br>            <!-- 
                使用around的时候 需要在增强方法传入一个ProceedingJoinPoint类型的对象，在该对象.proceed();前后各执行一个方法，这是环绕通知
                public void printEditLog(ProceedingJoinPoint pjp){
                    printQuerytLog();
                    try {
                        pjp.proceed();
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                    }
                    printEdit();
                }
            --><br>        <br>    </p>
<p>##SpringMVC:<br>    其中关于日期的转换问题：<br>        1.前端传值到方法中进行参数绑定时，会出现日期格式为null，此时需要写一个日期转换类，继承Converter接口<br>                public class DateConverter implements Converter&lt;String, Date&gt; {}<br>            然后在springmvc.xml文件进行注册<br>            <bean class="org.springframework.context.support.ConversionServiceFactoryBean" id="converterDate"><br>                    <property name="converters"><br>                        <set><br>                            <bean class="com.zz.util.DateConverter"></bean><br>                        </set><br>                    </property><br>                </bean><br>            在mvc的注解驱动中绑定<br>                &lt;mvc:annotation-driven conversion-service=”converterDate”/&gt;<br>        2.后端返回json类型的实体数据带有日期格式，前端接受的为此时间到1970-01-01的毫秒数，需要在实体类继承JsonSerializer<date><br>            重写方法public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {<br>                        SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd : hh:mm:ss”);<br>                        String s = sdf.format(date);<br>                        jsonGenerator.writeString(s);<br>                    }<br>            在日期类型的get方法上@JsonSerialize(using = 实体类.class)<br>    springMVC实现文件上传：<br>        首先需要在springmvc.xml文件配置<br>            <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>                <property name="maxUploadSize" value="104857600"></property><br>            </bean><br>        然后在tomcat服务器的配置文件中配置（tomcat X.X/conf/web.xml的servlet标签中）<br>            <init-param><br>                <param-name>readonly</param-name><br>                <param-value>false</param-value><br>            </init-param><br>        1.同服务器上传：<br>            public String uploadTest(HttpServletRequest request, MultipartFile upload) throws IOException {<br>                String path = request.getSession().getServletContext().getRealPath(“/upload”).toString();<br>                File file = new File(path);<br>                if (!file.exists()){<br>                    file.mkdirs();<br>                }<br>                String filename = upload.getOriginalFilename();<br>                filename = UUID.randomUUID().toString()+”-“+filename;<br>                upload.transferTo(new File(file,filename));<br>                return “index”;<br>            }<br>        2.跨服务器上传：<br>            public String uploadOther(MultipartFile upload) throws IOException {<br>                String path = “<a href="http://localhost:8081/upload/&quot;" target="_blank" rel="noopener">http://localhost:8081/upload/&quot;</a>;<br>                File file = new File(“/upload”);<br>                if (!file.exists()){<br>                    file.mkdirs();<br>                }<br>                String filename = upload.getOriginalFilename();<br>                Client client = Client.create();<br>                WebResource resource = client.resource(path + filename);<br>                resource.put(upload.getBytes());<br>                return “index”;<br>            }</date></p>
<p>##SSM整合：<br>    引入jar包<br>        Spring(context,aop,tx,aspectjweaver,web,webmvc,jdbc,test)<br>        MyBatis(mybatis,mybatis-spring)<br>        其他(junit,mysql,druid,jackson-core/databind/annotations,log4j,slf4j-log4j12)<br>    配置web.xml<br>        配置监听器(org.springframework.web.context.ContextLoaderListener)<br>        通过上下文加载applicationContext.xml<br>        配置前端控制器<br>            class:org.springframework.web.servlet.DispatcherServlet<br>            通过指定init-para来加载spring-mvc.xml<br>        配置字符编码过滤器……<br>    编写实体类、mapper接口、mapper.xml<br>        配置applicationContext.xml<br>        扫包（必要）<br>        配置数据源：<br>            <bean id="datasource" class="com.alibaba.druid.pool.DruidDataSource"> 注入属性</bean><br>        整合mybatis<br>            将mybatis的sqlSessionFactory交给spring管理(class=”org.mybatis.spring.SqlSessionFactoryBean”)<br>                注入属性：数据源,mapper.xml映射文件的路径，配置实体别名<br>            配置mapper接口的包所在位置，让spring容器管理(class=”org.mabatis.spring.mapper.MapperScannerConfigurer”)<br>                注入属性：mapper接口所在位置，sqlSessionFactoryBeanName        !!!!!!注入sqlSessionFactory时不要使用ref，要用value<br>        配置事务管理器<br>            class=”org.springframework.jdbc.datasource.DataSourceTransactionManager”    注入数据源<br>        开启对事务注解的支持：&lt;tx:annotation-driven transaction-manager=”事务管理器的id” /&gt;<br>    配置spring-mvc.xml<br>        扫包（必要）<br>        开启对mvc注解的支持<br>        配置视图解析器：class=”org.springframework.web.servlet.view.InternalResourceViewResolver”<br>            配置前缀，后缀<br>        配置静态资源<br>            配置全局异常处理类时可以在spring的配置文件也可以在springmvc的配置文件</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 ZMC
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>